[{"title":"当Qt(C++)中，function成为first-class","date":"2017-02-07T10:53:35.000Z","path":"2017/02/07/当Qt(C++)中，function成为first-class/","text":"我对C++的使用和理解是不断变化的。从一开始的C with Class 到接触到设计模式，才理解了什么叫真正的OOP；从接触到STL才真正正视Template，了解了什么是GP；从Python和Golang的火热中了解了函数作为first-class的力量；从某些文章对Lisp近乎玄学的推崇中知道了FP的优势和它逐渐在主流的编程方式中兴起的原因。C++是包容和自由的，自从学了std::function和lambda之后，我也开始逐渐学着向FP方式转变。因为在很多方面，将function作为first-class，对编码带来的不只是形式上的变化，更是思维方式的变化。 lambda与QObject::Connect C++11 lambda表达式和Qt5的搭档，使得可以可以放弃SIGNAL、SLOT宏，采用一种更加直观和简洁的方式使用Connect。使用lambda之前，如果要在Qt的main函数里使用slot，不得不另外构造一个类继承QObject，并且定义槽函数，然后才能在main里实例化对象并绑定槽函数： //myObject.h #include &lt;QObject&gt; class myObject : public QObject { public: myObject(QObject* parent = 0); ~myObject(); public slots: void onClicked(); }; //myObject.cpp ...... void myObject::onClicked(){ qDebug() &lt;&lt; &quot;clicked&quot;; } //main.cpp #include &lt;QApplication&gt; #include &lt;QDebug&gt; #include &lt;QPushButton&gt; #include &quot;myObject.h&quot; int main(int argc, char *argv[]) { QApplication app(argc, argv); QPushButton *button = new QPushButton(&quot;click&quot;); button-&gt;show(); myObject *obj = new myObject(); QObject::connect(button, SIGNAL(clicked()), obj, SLOT(onClicked())); return app.exec(); } 为了一个槽函数，还要引入另一个类，实在是大动干戈，而且还不直观（这可能也是OOP为人诟病的一个方面吧）。在有了lambda之后，是这么干的： #include &lt;QDebug&gt; #include &lt;QPushButton&gt; int main(int argc, char *argv[]) { QApplication app(argc, argv); QPushButton *button = new QPushButton(&quot;click&quot;); button-&gt;show(); QObject::connect(button, &amp;QPushButton::clicked, []() { qDebug() &lt;&lt; &quot;clicked&quot;; }); return app.exec(); } 简洁！一目了然！！ 虚函数与std::function 上面的例子其实还有类似的情况，在QWidget上想要自定义鼠标press事件，我们有两种方式： 该widget外部使用eventfilter来拦截该widget的鼠标press事件并处理 自定义继承自QWidget的widget类并覆盖其mousePressEvent()的虚函数 第一种方式不直观，对该控件的处理要到别的地方去寻找，不是很“OOP”；第二种方式和上一例子一样，代价有点大。其实这样的例子还有很多。传统的OOP在解耦的同时一定会导致体型的臃肿，除此之外还经常会有将处理流程隐藏在层层的封装和继承之中导致的不直观不清晰的问题。代码说到底是人来写人来读的，任何反直观的都是不好的。编程就像写文章，诘屈聱牙的东西没人愿意看，好的代码一定是读起来酣畅淋漓的。如果我们自己实现一个Button类，可以是这样的： //Button.h class Button { ...... virtual void onClicked() = 0; }; //MyButton.h class MyButton : public Button { ...... void onClicked(){ //需要的操作 } }; 这样，在我们需要一个Button的时候，新写一个类继承Button，将点击的处理写在onClicked方法内即可。可以，这很“OOP”。现在呢，我们可以利用std::function，使得函数作为类成员，像对待类的普通成员一样对函数成员进行赋值操作，即可得到我们需要的对象： //Button.h class Button { ...... std::function&lt;void()&gt; _onClicked; }; //在使用的地方 Button btn; btn._onClicked = [](){ //需要的操作 }; 喏，更加的简单明了。函数不需要通过继承来特化，而是通过像普通变量一样的方式直接实例化，带来的不光是结构 上的简单，还有语意上的直白。 ScopeGuard 资源的释放从来都是一个问题。文件句柄、锁、等等资源，申请的时候我们可能想着一会儿用完要释放，等到用完之后可能就忘了，或者是因为分支处理漏掉了，这都是很有可能发生的，就算没有在分支处理中漏掉，在各个分支里都重复的写同样的释放资源的代码也很不fashion，没人愿意当CV战士。利用RAII特性，局部变量析构时候释放资源已经成为一个通用做法。麻烦的是我们需要为各种资源都创建类来利用其析构函数释放资源，太麻烦。现在有了std::function就好了，借鉴一下std::lock_guard，就有了下面的做法： //ScopeGuard.h class ScopeGuard { public: explicit ScopeGuard(std::function&lt;void()&gt; callback) : _onExit(callback) {}; ~ScopeGuard(){ _onExit(); }; private: std::function&lt;void()&gt; _onExit; }; #define ON_SCOPE_EXIT(callback) ScopeGuard EXIT##__LINE__(callback) //在使用的地方 { HANDLE f = fopen(&quot;conf.yaml&quot;); ON_SCOPE_EXIT([=](){ fclose(f); }); ...... { _mutex.lock(); ON_SCOPE_EXIT([&amp;](){ _mutex.unlock(); }); ...... } ...... } 资源创建之后，立即跟在后面写释放方式，不会忘不会漏，看起来还明确。ON_SCOPE_EXIT宏作用在于创建了一个ScopeGuard局部变量；变量名由行号确定，避免了多个ScopeGuard重名的问题。 其它 将function作为first-class带来的改变还有很多，比如将function保存在容器中，将function作为值传递给别的线程执行，返回闭包来创建累加器等等。 初极狭，才通人。复行数十步，豁然开朗。","tags":[{"name":"C++ Qt","slug":"C-Qt","permalink":"http:/tags/C-Qt/"}]},{"title":"浅谈Singleton","date":"2017-01-22T18:36:20.000Z","path":"2017/01/23/浅谈Singleton/","text":"我们在实现单例模式时，考虑的第一点是对象的创建和访问只有一个共同的入口，所以必须满足以下两个条件： 访问入口是与对象无关的 构造函数必须是隐藏的，不能被外部通过直接调用产生新对象 所以我们的实现中有两个关键点： 静态方法getInstance做为访问入口 将构造函数设为private 根据这两个原则，我们先有了第一版简单实现： V1.0 //Singleton.h class Singleton{ public: static Singleton* getInstance(); private: Singleton(){}; static Singleton _instance; }; //Singleton.cpp Singleton Singleton::_instace; Singleton* Singleton::getInstance(){ return &amp;_instance; } 这里貌似是把Singleton实现的很好，完全符合上述提到的两点。但是“一切代码都没有完美的”，我们总能找出缺点和问题的。比如这里，_instance对象是声明为static的，即在程序运行之初就初始化在静态存储区域了。但是万一我的整个程序中根本就没用到这个对象呢？这时候这就是一种浪费了。就算是在程序中用到了，我也希望是在我第一次使用它时，它才被创建并初始化的。在《Effective C++》的条款04中，Scott Meyers更是指出了这种实现方式的严重的错误之处：假设有两个Singleton类，其中一个以另一个为参数进行初始化，即存在一个 static SingletonA SingletonA::_instance 和另一个以此为参数初始化的 static SingletonB SingletonB::_instance(SingletonA::_instance) ，这两个non-local static对象位于两个不同的编译单元内，而C++对于“定义于不同的编译单元内的non-local static对象”的初始化相对次序并无明确定义。所以就会出现SingletonB::_instance对象在SingletonA::_instance对象之前初始化，那就意味着此时SingletonA::_instance处于“半随机”状态，这会导致不可测知的程序行为。所以我们有了下一个版本： V1.1 //Singleton.h class Singleton{ public: static Singleton* getInstance(); private: Singleton(){}; }; //Singleton.cpp Singleton* Singleton::getInstance(){ static Singleton _instance; return &amp;_instance; } 这也是Scott Meyers在《Effective C++》中提出的方法——用local static替换non-local static， 这样不仅解决了初始化次序问题，同时实现了lazy initialization。当然，“一切代码都没有完美的”，考虑到多线程系统中与初始化相关的race conditions：当多个线程同时第一次调用getInstance()，此时会多次产生静态对象。Scott Meyers提出的解决方法是，在程序的单线程启动阶段，手工的调用getInstance()方法。这并不是一个优雅的写法，我们希望只在真正需要对象的时候才去调用getInstance()。那么就需要在getInstance方法里加锁保护。所以我们又有了下一个版本： V1.2 //Singleton.h #include &lt;mutex&gt; class Singleton{ public: static Singleton* getInstance(); private: Singleton(){}; static std::mutex _mutex; }; //Singleton.cpp std::mutex Singleton::_mutex; Singleton* Singleton::getInstance(){ std::lock_guard&lt;std::mutex&gt; lck(_mutex); static Singleton _instance; return &amp;_instance; } 这里又引入了一个新的non-local static变量Singleton::_mutex，是不是感觉是在拆东墙补西墙？幸好的是这里无需面对初始化次序的问题，Singleton::_mutex的初始化不依赖其他静态对象，而lazy initialization在这里也不是什么大问题，也就顾不上了。虽然通过加锁互斥解决了静态变量初始化的线程安全问题，但是考虑另一种调用情形：当_instance已经在之前的调用中构造出来了，然后此时再次调用getInstance()方法时，仍然需要对锁进行操作，这样显然是不合理的。应该在判断_instance已经存在并初始化之后就直接返回其指针，不做锁操作。那么就需要再引入一个non-local static变量来表示是否已初始化过，OMG！那么干脆就用一个指针来指代_instance对象吧，这样也就可以用指针是否为NULL来判断对象是否已创建。下面是我们的判断对象是否已创建的指针版本： V2.0 //Singleton.h #include &lt;mutex&gt; class Singleton{ public: static Singleton* getInstance(); private: Singleton(){}; static std::mutex _mutex; static Singleton* _instance; }; //Singleton.cpp std::mutex Singleton::_mutex; Singleton* Singleton::_instance = NULL; Singleton* Singleton::getInstance(){ if (NULL == _instance){ std::lock_guard&lt;std::mutex&gt; lck(_mutex); _instance = new Singleton(); } return _instance; } 这样好像是把问题都解决了。慢着，当两个线程同时第一次调用getInstance时，都会判断 NULL == _instance 条件成立，于是都要执行构造对象操作，由于锁的存在，同时只会有一个线程构造对象，但是当前一个线程构造完毕之后就退了锁，于是第二个线程进去了，继续重新构造对象。看来只有在加锁之后对 NULL == _instance 条件再进行一次判断了。加锁前后两次判断的版本： V2.1 //Singleton.h #include &lt;mutex&gt; class Singleton{ public: static Singleton* getInstance(); private: Singleton(){}; static std::mutex _mutex; static Singleton* _instance; }; //Singleton.cpp std::mutex Singleton::_mutex; Singleton* Singleton::_instance = NULL; Singleton* Singleton::getInstance(){ if (NULL == _instance){ std::lock_guard&lt;std::mutex&gt; lck(_mutex); if (NULL == _instance){ _instance = new Singleton(); } } return _instance; } 这种方式称之为 Double-Checked Locking 技术。那么，这个方式还有没有改进的空间呢？当然，“一切代码都没有完美的”，试想我们的系统中有很多类是Singleton模式时，难道我们要把这套方法对每个类都复制一遍么？为了避免代码重复，我们怎么去实现呢？继承？抑或者类模板？ 路漫漫其修远兮，吾将上下而求索","tags":[{"name":"C++","slug":"C","permalink":"http:/tags/C/"}]}]